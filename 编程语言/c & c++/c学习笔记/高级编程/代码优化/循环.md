### 选择好的无限循环

常用的两种方法是while (1) 和for(；；) 这两种方法效果完全一样，但那一种更好呢？然我们看看它们编译后的代码：  

```
编译前：  
while (1)；  
编译后：  
mov eax，1  
test eax，eax
je foo+23h
jmp foo+18h 
编译前：
for (；；)；
编译后：
jmp foo+23h
显然，for (；；)指令少，不占用寄存器，而且没有判断、跳转，比while (1)好。
```

* 在 ubuntu 使用 gcc 测试，发现编译出的汇编是一样的，说明现在gcc 已经做了优化

### 循环比较方式 

```
A ：for (i = 0; i < 20; i++) 
和 
B ：for (i = 20; i ; i--)
```

* 在 ubuntu 上编译成汇编后发现
B 每个循环会比 A 少一条语句，所以 B 执行效率越高 

### 循环比较变量
```
short i；

for (i=0; i<9; i++)
```

* 在32位的程序中,使用int类型作循环体的索引变量比short类型具有更好的性能;
* 在32位的应用程序中使用short将导致机器码变长，同时处理器需要更长的时间处理；不仅如此，大多数编译器在未优化状况下对于short类型,总是将它转换成integer后再做各种操作，操作完后再转换为short类型,增加了一些不必要的操作。
* 32位系统每次数据读取都是32位，使用short，16位意味着cpu需要而外的处理

### 在循环体中尽量少使用指针
```
原始代码：
       int   i, j = 0, *a = &j;
      for (i=0; i
      {
          *a += i;
      }
优化代码：
       int   i, j = 0, *a = &j;
       register int      temp;
       temp = *a;
       for (i=0; i
       {
           temp += i;
       }
       *a = temp;
```

* 指针是间接寻址；间接寻址将导致至少两次以上的内存操作
* 间接寻址使得指令具有前后的依赖性（只有先获得地址才能够做取内存内容的操作），编译器的优化能力将被降低，同时对处理器中流水线的乱序，调度和指令配对也会有一定的影响。

### 循环体内存在逻辑判断

```
原始代码：
for (i=0; i
        {
    if (condition)
        DoSomething();
    else
        DoOtherthing();
}

优化代码：
if (condition)
{
    for (i=0; i
        DoSomething();
        }
else
        {
            for (i=0; i
        DoOtherthing();
        }
```

* 循环体内的逻辑判断需要仔细思考 是否有必要循环判断

### 循环体内的处理

```
char *buf;

for (i=0; i
{
    buf = getAddr();    
}
```

* 如果 getAddr 函数返回的地址不会变化的话，没必要每次都去获取

### 将一个循环体内部的浮点除法操作，改成浮点乘法 
```
原始代码：
                  int i;
    double j;
 for (i=0; i<0xffffff; i++)
                   {
                        j = (double)i / 3.3;
                   }
优化代码：
    int i;
           double j, k;
    k = (double)1.0 / 3.3;
    for (i=0; i<0xffffff; i++)
    {
           j = (double)i * k;
     }
```

* 浮点数的除法比乘法要慢得多；如果是整数的乘法和除法是没有任何差异的，但是在适当地时候可以使用移位操作来提高效率，比如说将num乘以16的操作变为num<<4可以取得更好的效果，同理可应用于除法和求余，除法使用右移操作，求余使用%操作都可以取得不错的效果，至少在新版本的linux内核中已经在除法和求余操作上做了大量的改进。

### 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨界循环层的次数。 
