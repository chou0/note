* 内存对齐的原因是：32位cpu 的数据总线， 控制总线是32根，1根表示一位，因此每次读取数据都是4个字节，但是cpu 一次读取不能从任意地址开始读取，因此就会有这样的问题，就是假设数据的起始位置刚好在cpu不能开始读取的地址，cpu 就需要读取两次或多次来拼接成一个完整的数据
* 为了提高效率，编译器会将数据进行内存对齐，以便cpu能够一次读取所需，表现在于：
数据存储在内存时的起始地址是否是某个值的整数倍
* 既然编译器都弄好了，相对于程序员而言就是透明的了，那为什么有时会出问题，并且需要程序员去了解呢！

### 问题
* 如果只是放在内存中，是否对齐本身并没有什么问题。问题是读取、写入的时候。访问一个不对齐的数据（unaligned memory access）可能会导致程序运行效率慢，结果出错，甚至是程序当掉。那这些情况是怎么出现的呢？
1. char * 或者 void * 进行类型转换时 就会导致对齐问题，因为任意一个指针，不一定是对齐的

### 解决
* 当需要使用指针进行类型转换时，使用memcpy 先将数据拷贝至相应的数据类型
* memcpy 为什么不会有问题？因为当内存不是对齐的话，memcpy 是按照逐字节拷贝的，当对齐后，再按照数据总线位数读取，

### 问题2
```
#pragma pack(push,1)
```
* 对于c或c++语言，可以使用命令更改内存对齐的长度，这样是编译器使用了一些指令，在牺牲性能的情况下，实现的
