## 设备情况
* 由 FPGA人脸检测算法板 + his3516a 主控板组成
* FPGA人脸检测算法板 负责人脸的检测和跟踪
* his3516a 主控板负责人脸抓拍等应用

## 前言
* FPGA 是通过串口将人脸数据发送给 ARM 主控板
* 协议包以 0xfb 0x71 开头，包头 msg_head 包括 0xfb 0x71是8个字节，包头的第4个 和第5个字节是除包头外的协议包数据长度

## 需求
* 需要有超时机制，当一段时间后没有收到数据，需要发送心跳包，收到心跳包回应后再进入正常逻辑

## 测试
* 每次串口接收数据不一定是一个完整的协议包，可能少于也可能多于
* 每个协议包之间可能会有多余数据
* 协议包随着检测到的人脸个数而扩大，没有确切长度限制

## 1次接收返回的条件
1. 解析出一个完整的协议包，返回数据包
2. 发生接收超时，返回超时，进入心跳机制

## 方案选择
* 早期采用内存池方案，由一个接收模块接收数据，进行数据处理；后期采用按长度读取方案

## 内存池方案
* 超时是使用的select 实现的，按需读取不是非常方便，最简单的方法是一次将数据全部读取出来
* 因此设计了一个内存池来存储接收的数据；进行拆包和拼包
* 申请了一块 3500 bytes大小内存（理论上足够大），记录 start 和 end，数据从end 处开始接收，
* 为了效率 没有将协议包完整复制一份给处理模块，直接返回的指针，
* 当内存池存储满后，处理后还有多余的数据需要将多余的数据拷贝至内存池起始位置
* 当包比较大时，容易导致多余数据较多，memcpy导致性能降低
* 从first 开始找协议头，根据协议长度判断 当前end - first 是否有一个完整的协议包，没有的话再进行串口接收，有的话 first 加上整个协议包长度，end 等于 first，将它们都至0，

## 按长度读取方案
* 串口本身支持超时，设置时间限制后，read 如果返回0表示超时，如此按需读取的话会比较容易实现
* 也没有 memcpy 造成的性能问题，也不需要多调用一次 select 函数
* 做法：（下列操作接收到 数据个数为0，都退出函数，返回超时）
1. 循环接收 1 bytes数据，直至 数据为 0xfb
2. 只接收 1 bytes数据，若 数据为 0x71 则向下执行，若数据为 0xfb，则再进行第二步，否则退回 第一步，
3. 再接收 6 bytes数据，解析出 后续len
4. 再读取 len bytes数据