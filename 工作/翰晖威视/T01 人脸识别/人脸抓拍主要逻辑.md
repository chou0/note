## 模块划分
* 当前划分为 3个线程实现
1. 线程1，维护帧缓存，给每帧加上id（或时间戳）
2. 线程2，周期接收算法板的人脸数据返回，并处理，主要维护人脸集合
3. 线程3，策略&抠图线程

* 线程2，3的分开原因是，每次抠图需要时间较长，人脸图较大的话，可能接近40ms，而 算法人脸数据返回周期只有50ms，合在一起的话，抠图会阻塞处理，导致数据丢失

## 线程1
1. 最耗性能的测试是抠图，因此一个人脸尽量少抠图
2. 帧缓存，每一帧数据结构，包含 帧数据，帧id，use（人脸引用个数）
3. 人脸集合，每个人结构中有 帧index，指向帧缓存数组中index节点
4. 线程1，加id操作需要跳过 use 不为0的帧，表示被人脸占用了
5. 有很多地方需要对 use 进行加减需要注意

## 线程2
* 周期接收算法板人脸数据返回，主要更新 人脸最后出现的 时间戳（或者帧号），注意，这个不能被抓拍选项过滤影响，
* 因为 没有人脸数据返回，线程2 不会返回数据，设置非阻塞的，加上策略，担心运行过多，阻塞后续数据，希望每次人脸数据的处理能够精简，快速，因此线程2只维护 人脸集合，最后出现的帧id，以及最优人脸的 帧缓存index
* 获取到的人脸数据是一个数组，需要遍历，每个人脸，需要在人脸集合中查找，找不到需要新生成并插入集合，

## 线程3
* 线程2 对人脸集合需要遍历和插入操作，而线程3 对人脸集合也需要遍历和删除节点操作，需要加锁，锁内的处理尽量简短
* 根据策略遍历人脸集合，并对符合条件的人脸节点进行抠图上传操作，当需要抠图的人脸很多时，会导致 锁住的时间太长，导致线程2的阻塞，因此将需要抠图的人脸的数据拷贝出来，在锁外执行